#include <SFML/Graphics.hpp>
#include <cmath>
#include <chrono>
#include <thread>
#include <vector>
#include <set>
#include <iostream>

using namespace sf;

//================================================//
//  !!!ПОСЛЕ ТЕСТОВ ЗАКОММЕНТИРОВАТЬ ВСЕ СOUT!!!
//================================================//



//возможно надо заменить double на float, чтобы было быстрее
const double PI = 3.14; //число пи 
const double g = 0.10; //ускорение свободного падения
const int coef = 1; //коэф пропорциональности между силой отталкивания и массами частиц деленными на расстояние между ними
const int boundX = 1200; //размеры открываемого окна в sfml
const int boundY = 800; //размеры открываемого окна в sfml
const float Radius_of_Interaction = 1; //радиус области взаимодействия данной частицы с остальными



long double Find_Distance(double x1, double y1, double x2, double y2) { //ищет расстояние между центрами двух частиц
	return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

void sleep(int mc) {
	//задержка на ms микросекунд
	std::this_thread::sleep_for(std::chrono::microseconds(mc));
}


class Particle
	//класс самого градиента "молекулы" и ее отображения в виде частицы
	//умеет притягиваться к земле, отталкиваться от других частиц и обладает вязкостью
	//обитает в двумерном простратстве (пока что)
{

private:
	sf::CircleShape circle; //каждая частица отображается кругом 
	const double r = 8; //радиус отображаемой частицы
	double vx = 0; //скорости
	double vy = 0;
	const int mass = 1; //масса, сосредоточенная в центре

	//===================================================================================//
	const float a = 1; //смещение 1/x^2 по осям x и у в методе Gradient_of_Interaction
	const float alpha = 1; //коэф растяжения 1/x^2 в методе Gradient_of_Interaction
	//===================================================================================//

public:
	Particle() { //создает голубую частицу с коорд 0::0
		sf::Color circleColor(100, 255, 127);
		circle.setFillColor(circleColor);
		circle.setPosition(0, 0);
		circle.setRadius(r);
		std::cout << "голубая частица с координатами" << 0 << "::" << 0 << "создалась" << std::endl;
	}
	Particle(float x_, float y_) { //создает частицу с коорд х::у
		sf::Color circleColor(100, 255, 127);
		circle.setFillColor(circleColor);
		circle.setPosition(x_, y_);
		circle.setRadius(r);
		std::cout << "голубая частица с координатами" << x_ << "::" << y_ << "создалась" << std::endl;
	}

	double GetX() { return this->circle.getPosition().x; } //геттеры и сеттеры для коорд
	double GetY() { return this->circle.getPosition().y; } //по сути они уже встроены в sfml, но так код получается слишком длинный(
	void SetX(double x_) { double x = GetX(); double y = GetY(); this->circle.setPosition(x_, y); }
	void SetY(double y_) { double x = GetX(); double y = GetY(); this->circle.setPosition(x, y_); }

	double GetVx() { return this->vx; } //геттеры и сеттеры для скоростей
	double GetVy() { return this->vy; }
	void SetVx(double vx_) { this->vx = vx_; }
	void SetVy(double vy_) { this->vy = vy_; }

	void Earth_Gravity() { this->vy += g; } //гравитация, притягивает частицу вниз

	double Gradient_of_Interaction(Particle A) {
		//рассчитывает величину "поля" данной частицы в точке другой частицы A с коорд x::y
		//возвращает 0, если частица вне радиуса взаимодействия, величину "градиента" в противном случае
		//величина "градиента" зависит от координаты как 1/x^2, причем гипербола смещена вправо на константу a по оси х, вниз на а по оси у и растянута в альфа раз
		//!АЛЬФУ В ФОРМУЛЕ НУЖНО ПОМЕНЯТЬ
		//ro - расстояние от данной частицы до частицы А
		double ro = Find_Distance(A.GetX(), A.GetY(), this->GetX(), this->GetY());
		if (ro >= Radius_of_Interaction) return 0;
		return (alpha / ((ro + a) * (ro + a)) - a);
	}

	void move() {  //движение частицы
		double x = GetX();
		double y = GetY();
		this->circle.setPosition(x += vx, y += vy); 
	}


	long double Find_speed() { return sqrt((this->vx) * (this->vx) + (this->vy) * (this->vy)); } //вычмсляет полную скорость частицы


	sf::CircleShape GetCircle() { return this->circle; } //нужна только для отрисовки круга

	void rebound() {
		//когда частица врезается в стену/пол, она отскакивает, теряя часть энергии
		if (this->GetY() - boundY + 15 > -5) { //сила трения о пол
			this->SetVx(this->GetVx() * 0.97);
			if (abs(this->GetVx()) <= 0.1) this->SetVx(0); //если скорость слишком мала, то остановка
		}
		if (this->GetX() > boundX - 15) {
			this->SetX(boundX - 15);
			this->SetVx(-this->GetVx() * 0.7);
		}
		else if (this->GetX() < 0) {
			this->SetX(0);
			this->SetVx(-this->GetVx() * 0.7);
		}
		if (this->GetY() > boundY - 17) {
			this->SetY(boundY - 17);
			this->SetVy(-this->GetVy() * 0.7);
			if (abs(this->GetVy()) <= 0.2) this->SetVy(0); //если скорость слишком мала, то остановка
		}
	}

	void recolour() {
		//цвет частицы зависит от ее скорости
		int red;
		int green;
		int blue;
		if ((int)this->Find_speed() * 6 > 127) { //если скорость слишком большая, то цвет больше не меняем
			red = 100;
			green = 255;
			blue = 127;
			return;
		}
		red = 100;
		green = 120 + (int)(this->Find_speed() * 6);
		blue = 240 - (int)(this->Find_speed() * 6);
		sf::Color circleColor(red, green, blue);
		this->circle.setFillColor(circleColor);
	}


};



void Molecular_Interaction(Particle A, Particle B) { //взаимодействие между частицами
	//ТУТ ПОТОМ БУДЕТ КАРТА ГРАДИЕНТА И ХЭШИРОВАНИЕ
	//============ ДОПИСАТЬ ===============//
	std::cout << "Взаимодействие между частицами работает!" << std::endl;
}

void left_mouse_click(Particle &A, RenderWindow* window_ptr) {
	//реализуем притяжение к курсору при нажатии мыши
	//есть два варианта: с зависимостью от длины и от длины в квадрате
	//выбираем второй, так как хотим больше взаимодецствовать с близкими частицами
	sf::Vector2i mousePosition = sf::Mouse::getPosition(*window_ptr);
	sf::Vector2f direction = sf::Vector2f(mousePosition) - A.GetCircle().getPosition();
	float length = std::sqrt(direction.x * direction.x + direction.y * direction.y);
	//direction /= (length / 0.4);
	direction = (Vector2f)(direction * 100.0f / (length * length));

	double vx = A.GetVx();
	double vy = A.GetVy();

	vx += direction.x;
	vy += direction.y;
	if (length < 40) return; //при зависимости от квадрата длины частицы не должны приближаться к курсору слишком сильно
	A.SetVx(vx);
	A.SetVy(vy);
}

void right_mouse_click(Particle& A, RenderWindow* window_ptr) {
	//реализуем отталкивания от курсора при нажатии мыши
	sf::Vector2i mousePosition = sf::Mouse::getPosition(*window_ptr);
	sf::Vector2f direction = sf::Vector2f(mousePosition) - A.GetCircle().getPosition();
	float length = std::sqrt(direction.x * direction.x + direction.y * direction.y);
	direction = (Vector2f)(direction * 100.0f / (length * length));

	double vx = A.GetVx();
	double vy = A.GetVy();

	vx -= 0.3 * direction.x;
	vy -= 0.3 * direction.y;

	A.SetVx(vx);
	A.SetVy(vy);
}



int main()
{
	setlocale(LC_ALL, "Russian");
	sf::RenderWindow window(sf::VideoMode(boundX, boundY), "Fluid simulation");

	Particle particle_1(600, 400); //создаем одну частицу с кооординатами и скоростями


	/*int x_number_of_particels; //определяет размер массива (прямоугольника), заполненного частицами
	int y_number_of_particels;
	std::cout << "Введите размеры прямоугольника частиц: " << std::endl;
	std::cin >> x_number_of_particels >> y_number_of_particels;

	Particle** ptr_for_particles_arrays = new Particle*[x_number_of_particels]; //создаем двумерный массив для частиц
	for (int i = 0; i < x_number_of_particels; i++) {
		ptr_for_particles_arrays[i] = new Particle[y_number_of_particels];
	}*/
	
	while (window.isOpen())
	{
		sf::Event event;
		while (window.pollEvent(event))
		{
			if (event.type == sf::Event::Closed)
				window.close();
		}

		particle_1.rebound(); //частица отталкивается
		particle_1.Earth_Gravity(); //притягивается к земле 1 раз
		particle_1.recolour(); //меняет цвет
		particle_1.move(); //движется
		particle_1.Earth_Gravity(); //притягивается к земле 2 раз

		if (sf::Mouse::isButtonPressed(sf::Mouse::Left)) left_mouse_click(particle_1, &window); //притяжение к курсорe при нажатии лкм
		else if (sf::Mouse::isButtonPressed(sf::Mouse::Right)) right_mouse_click(particle_1, &window); //отталкивание от курсора при нажатии пкм

		sleep(50);
		window.clear();
		window.draw(particle_1.GetCircle());
		window.display();
	}

	return 0;
}
